### Генерация (псевдо)случайных чисел

##### C-style

Классический способ генерации случайных чисел в языке C - использование функций `srand` и `rand`. Первая задает так
называемое "зерно" распределения, вторая генерирует случайное целое число из диапазона от 0 до `RAND_MAX` включительно.
При этом "зерно" (аргумент `srand`) однозначно задает последовательность генерируемых `rand()` чисел.

Пример:

```c++
// Сгенерируем случайные числа на отрезке [0, 1]
#include <cstdlib>
// ...
std::srand(11);
std::cout << std::rand() / double(RAND_MAX) << '\n';  // A
std::cout << std::rand() / double(RAND_MAX) << '\n';  // B (с большой вероятностью B != A)

std::srand(11);  // заново инициализируем рандом тем же числом
std::cout << std::rand() / double(RAND_MAX) << '\n';  // A' == A
std::cout << std::rand() / double(RAND_MAX) << '\n';  // B' == B

std::srand(13);  // инициализируем рандом другим числом
std::cout << std::rand() / double(RAND_MAX) << '\n';  // C != A (с большой вероятностью)
std::cout << std::rand() / double(RAND_MAX) << '\n';  // D != B (с большой вероятностью)
```

Зерно необходимо для воспроизводимости результатов во время отладки программы. Если бы при каждом запуске генерировались
разные последовательности, то было бы невозможно воспроизвести ситуацию, которая привела к ошибке в прошлый раз (не
говоря уже о том, что некоторые решения студентов сами являются еще теми генераторами случайных чисел).

На практике, если необходимо, чтобы генерируемые последовательности отличались от запуска к запуску, для зерна
используются внешние источники, например текущее время.

```c++
std::srand(std::time(0));
```

У такого подхода есть несколько существенных недостатков:
1. Невозможно контролировать качество генерируемых последовательностей. Генератор псевдослучайных чисел зашит где-то
внутри стандартной библиотеки и представляет собой "черный ящик".
2. `std::rand()` генерирует целое число из (приблизительно) равномерного распределения на [0, `RAND_MAX`]. А что если
хочется нецелое число? число из гауссовского (нормального) распределения?
3. Функции `srand` и `rand` используют общее *глобальное* состояние. То есть, если вы в одной функции изменили зерно, то
оно изменится для всей программы. Если вы сгенерировали число в одной функции, то в другой вы уже получите следующий
элемент последовательности.

Последний пункт является наиболее критичным. Мало того, что общение посредством глобальных переменных - это плохо (а
`rand` и `srand` по сути этим и занимаются), так еще это приносит большие проблемы в многопоточных программах, когда
последовательность исполнения инструкций может быть недетерминированной.

##### Генерация в стиле C++

Для генерации случайных чисел в современном C++ используются так называемые генераторы (например,
https://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine). Объекты этих классов имеют конструкторы от
зерна (аналог `std::srand`) и перегруженный оператор функционального вызова (круглые скобки) для получения очередного
случайного целого числа (аналог `std::rand`).

```c++
#include <random>
// ...
std::mt19937_64 generator(11);  // генератор случайных 64-битных целых чисел
std::cout << generator() << ' ' << generator();  // сгенерировали и вывели два числа через пробел
```

В стандартной библиотеке C++ реализовано сразу несколько классов-генераторов. Кроме того, вы можете создавать свои
генераторы. Таким образом, проблема 1 решена.

Генераторы решают и 3-ю проблему. Вы можете создавать локальные генераторы для каждой функции и класса по отдельности.
Они могут иметь разные зерна и никак не влияют друг на друга (обычные локальные переменные).

```c++
void First() {
    std::mt19937_64 generator(11);  // не зависит от второго
    // ...
}

void Second() {
    std::mt19937_64 generator(11);  // не зависит от первого
    // ...
}
```

Для решения проблемы 2 в современном C++ помимо генераторов есть классы *распределений*. Объекты этих классов имеют
перегруженную операцию функционального вызова, которая принимает объект генератора, генерирует случайное число и
переводит его в значение из требуемого распределения.

```c++
#include <random>
// ...
std::mt19937_64 generator(11);

std::uniform_int_distribution uniform(-10, 10);  // равномерное распределение на отрезке [-10, 10]
std::cout << uniform(generator) << ' ' << uniform(generator) << '\n';  // генерация чисел из равномерного распределения

std::cauchy_distribution cauchy;  // распределение Коши
std::cout << cauchy(generator) << ' ' << cauchy(generator) << '\n';  // генерация чисел из распределения Коши
```

##### Условие задачи

1. Необходимо написать функцию `NormalProbability`, которая эмпирически вычисляет вероятность попадания стандартной
гауссовской (нормальной) случайной величины в заданный промежуток `[low, high)`. Для этого необходимо сгенерировать
несколько (количество указано в третьем аргументе функции) значений из нормального распределения и вернуть долю
попаданий в требуемый промежуток. Объект генератора передается по ссылке последним аргументом.
2. Также реализуйте функцию `MonteCarloPi`, которая вычисляет приближенное значение числа $\pi$ методом
[Монте-Карло](https://graui.de/code/montePi/). TL;DR: метод основан на отношении площадей квадрата и вписанной в него
окружности, которое равно $\pi / 4$. Если взять случайные точки равномерно распределенные на квадрате и вычислить
долю точек, попавших внутрь вписанной окружности, то получим оценку этого отношения. 

Прототипы функций вы найдете в файле `random.h`

**Замечания.**

1. В качестве решения от вас ожидается файл `random.cpp` с реализациями функций.
