### Inserter

*Итераторные адаптеры позволяют использовать интерфейс итераторов и алгоритмов стандартной библиотеки для вставки
элементов в контейнеры. В частности, можно воспользоваться функцией `std::copy` для копирования объектов одного
контейнера в конец или начало другого. Обычные итераторы не позволяют этого сделать, так как не обладают полномочиями
увеличивать вместимость контейнеров.*

##### `std::back_insert_iterator`

[`back_insert_iterator`](https://en.cppreference.com/w/cpp/iterator/back_insert_iterator) - итераторный адаптер,
позволяющий добавлять элементы в конец контейнера. Как и любой другой итератор может быть разыменован (`*`) и
инкрементирован (`++`), однако эти операции буквально не делают ничего и служат лишь для того, чтобы удовлетворять
интерфейсу итератора. Адаптер создается от некоторого контейнера, который сохраняется в поле (в виде ссылки или
указателя). При присваивании ему некоторого значения адаптер вызывает метод `push_back`, добавляя это значение в
контейнер.

**Пример:**

```c++
std::vector<int> a{1, 2, 3};
std::vector<int> b{4, 5, 6};
std::copy(a.begin(), a.end(), std::back_insert_iterator<std::vector<int>>(b));  // копируем элементы a в конец b
// b = {4, 5, 6, 1, 2, 3}
```

Создание объекта может показаться довольно громоздким (`std::back_insert_iterator<std::vector<int>>(b)`). К счастью
есть стандартная функция `std::back_inserter`, которая принимает контейнер и возвращает требуемый итератор. Кроме того, 
начиная с C++17, конструкторы могут сами выводить шаблонный параметр класса, если это возможно:

```c++
std::vector a{1, 2, 3};  // int выводится автоматически
std::vector b{4, 5, 6};  // int выводится автоматически
std::copy(a.begin(), a.end(), std::back_inserter(b));
                       // или std::back_insert_iterator(b)
```

##### `std::front_insert_iterator`

[`front_insert_iterator`](https://en.cppreference.com/w/cpp/iterator/front_insert_iterator) - итераторный адаптер,
позволяющий добавлять элементы в начало контейнера. Контейнер должен поддерживать метод `push_front`. Работает
аналогично.

```c++
std::deque a{1, 2, 3};  // int выводится автоматически
std::deque b{4, 5, 6};  // int выводится автоматически
std::copy(a.begin(), a.end(), std::front_inserter(b));
                       // или std::front_insert_iterator(b)
// b = {3, 2, 1, 4, 5, 6}
```

##### `std::insert_iterator`

[`insert_iterator`](https://en.cppreference.com/w/cpp/iterator/insert_iterator) - итераторный адаптер,
позволяющий добавлять элементы в произвольное место контейнера. Контейнер должен поддерживать метод `insert`. В отличие
от предыдущих двух дополнительно принимает итератор на позицию в контейнере, в которую нужно вставлять элементы.

```c++
std::vector a{1, 2, 3};  // int выводится автоматически
std::vector b{4, 5, 6};  // int выводится автоматически
std::copy(a.begin(), a.end(), std::inserter(b, b.begin() + 1);
                       // или std::insert_iterator(b, b.begin() + 1)
// b = {4, 1, 2, 3, 5, 6}
```

##### Задание

Реализовать шаблонные классы `BackInsertIterator` (аналог `std::back_insert_iterator`), `FrontInsertIterator` (аналог
`std::front_insert_iterator`), `InsertIterator` (аналог `std::insert_iterator`), а также порождающие функции
`BackInserter`, `FrontInserter`, `Inserter`. Классы должны реализовывать:
* Конструктор от контейнера, в который нужно вставлять элементы (для `InsertIterator` дополнительно нужно передавать
итератор на позицию вставки).
* Операции присваивания от элемента контейнера (вызывает метод `push_back`, `push_front` или `insert`).
* Операции инкремента и разыменовывания, которые ничего не делают, лишь возвращают ссылку на себя.
