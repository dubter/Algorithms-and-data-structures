### BigInteger

*В C++ в отличие от, например, Python нет встроенных возможностей для работы с длинной арифметикой - вычислениями над
величинами превосходящими по размеру базовые типы. Несмотря на то, что типы `long long` и `unsigned long long`(~$10^19$)
покрывают большую часть практических вычислений, иногда бывает необходимо повысить точность выполняемых операций.

В этом задании необходимо реализовать класс `BigInteger` для работы с большими целыми числами, которые вмещают в себя
значения от $-N$ до $N$, где $N=10^{30,000}$*

##### Детали реализации

В качестве решения ожидается описание класса `BigInteger`. Для этого класса необходимо реализовать все требуемые
арифметические операции и сопутствующие методы, упрощающие работу с ним.

Длинное число можно представлять в памяти в виде массива цифр из некоторой системы счисления. Например, если в качестве
системы счисления взять `1000`, то каждый элемент массива будет представлять собой целое число из промежутка
$\[0, ..., 999\]$. Рекомендуется в качестве основания брать некоторую степень 10 для удобства ввода и вывода числа в
десятичной системе счисления (иначе придется выполнять перевод из одной системы в другую).

**Пример:**
*Пусть число представляется в виде массива 5 цифр из 1000-й системы счисления. Тогда десятичное число 1,234,567,890
будет представляться в памяти массивом \[890, 567, 234, 1, 0\] (сначала младшие разряды, затем старшие).*

При таком подходе достаточно просто реализовать операции сложения, вычитания и умножения над массивами "в столбик",
последовательно выполняя операции над цифрами.

Недостатком данного метода является неэффективное расходование памяти, выделяемое под число. Допустим, основание системы
счисления равно `10'000`, а цифра представляет собой беззнаковое 16-битное число, которое может вместить в себя `65'536`
значений. Получается, что в каждый момент времени, как минимум 2 бита расходуется в пустую.

Кроме того, при реализации сложения и умножения следует помнить, что результат их применения к цифрам может не
помещаться в заданный тип (9'999 * 9'999 не влезает в 16-битное число). Для решения этой проблемы можно было бы взять
тип "с большим запасом" - хранить цифры в 32-битных целых числах. Но это только усугубляет проблему, описанную в
предыдущем абзаце. В качестве альтернативы предлагается использование приведения целых типов к более широкому в момент
умножения, для получения корректного результата.

**Пример:**
```c++
using DigitType = uint16_t;        // тип цифры - 16 битное число
using DoubleDigitType = uint32_t;  // тип цифры с удвоенной шириной

digits_[i] * digits_[j];  // результат uint16_t - возможно переполнение
static_cast<DoubleDigitType>(digits_[i]) * digits_[j];  // результат uint32_t - нет переполнения
```

Для поддержки отрицательных чисел достаточно хранить булевский флаг "отрицательности" числа и соответствующим образом
корректировать операции в случае, когда он имеет значение `true`.

Полный набор операций, который необходимо поддержать:
* Создание на основе целого числа (конструктор от целых чисел) и на основе си-строки с десятеричным представлением
числа.
* `IsNegative()` - `true`, если число отрицательное.
* Унарные `+` и `-`.
* Сложение, вычитание, умножение с присваивающими аналогами.
* Те же операции со встроенными целыми числами.
* Префиксные и постфиксные инкремент и декремент.
* Оператор приведения к `bool`.
* Операции сравнения.
* Операции ввода из потока и вывода в поток.

При переполнении длинного числа, то есть если в результате операции количество десятичных цифр числа превосходит `N`
(формально в тестах разрешается погрешность в 9 цифр), то нужно бросать исключение типа `BigIntegerOverflow`.

**Замечания.**

1. Решение должно состоять из файла интерфейса `big_integer.h` и файла реализации `big_integer.cpp`.

2. В задаче есть открытые и закрытые тесты. Перед отправкой решения проверяйте его на открытых тестах (чуда не будет,
если есть ошибка в публичных тестах, то она проявится и на более сложных приватных).

3. Операции можно тестировать независимо на соответствующих задачах из Я.Контест.

4. Решение необязательно должно быть оптимальным. Сосредоточьтесь на корректности реализаций. Решения "столбиком" будет
достаточно.

5. "Бросить исключение типа `E`" значит - написать строку `throw E{};`. В этот момент выполнение функции прекращается и,
если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам
этого делать не нужно.

### Дополнительная часть

Реализуйте операции целочисленного деления и взятия остатка от деления. Заметьте, правила деления отрицательных чисел в
математике и C++ отличаются. От вас требуется реализация деления по правилам C++.

Решение необязательно должно быть оптимальным, но в меру. Подойдет решение "уголком", но линейный поиск делителя на
каждом шаге эффективным точно не назвать.

*Важно:* если вы выполнили это задание, добавьте в файл `big_integer.h` следующую строку, чтобы в тесты была включена
проверка этой части.

```c++
#define BIG_INTEGER_DIVISION_IMPLEMENTED
```
